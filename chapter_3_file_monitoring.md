## 第三章：檔案監控與變更捕捉：即時與穩定的平衡 (Chapter 3: File Monitoring & Change Capture: The Balance Between Real-time and Stability)

如果說「基準線」是靜態的狀態記錄，那麼「檔案監控」就是動態的事件觸發器。它是整個系統的「神經系統」，負責感知外界的風吹草動（檔案變更），並將這些信號準確、及時地傳遞給大腦（比較與分析核心）。然而，現實世界的檔案系統事件遠非想像中那麼純淨，它充滿了噪音、重複和延遲。本章將深入探討 `core/watcher.py` 如何應對這些挑戰，並在即時響應和系統穩定性之間取得精妙的平衡。

### 3.1 Watchdog 的角色：作業系統級的檔案事件監控

專案的核心監控能力由 `watchdog` 函式庫提供。您可以將 `watchdog` 想像成一個**高度靈敏的「檔案系統感測器」**。它並不是通過自己去輪詢檢查檔案的修改時間（那樣會非常低效，就像你每隔一秒鐘就去敲一次門，看看裡面有沒有人），而是聰明地利用了現代作業系統內建的高效檔案系統事件通知機制。

這些底層的作業系統機制包括：

*   **Linux** 上的 `inotify`：一個內核級別的事件通知系統，當檔案或目錄被訪問、修改、創建、刪除或移動時，會立即發出通知。
*   **Windows** 上的 `ReadDirectoryChangesW`：Windows API 提供的一個函數，允許應用程式監控目錄中的變更。
*   **macOS** 上的 `FSEvents`：macOS 提供的類似機制，用於監控檔案系統事件。

這種方式的優勢是顯而易見的：

*   **高效能**：事件是由作業系統核心在檔案操作完成時直接推送給應用程式的。這意味著系統不需要不斷地去「問」檔案系統有沒有變化，而是檔案系統在有變化時會主動「告訴」系統。這種「推 (Push)」模式相比於「拉 (Pull)」模式（輪詢）效率高得多，幾乎沒有延遲，且 CPU 佔用極低。
*   **即時性**：相比於每隔幾秒鐘檢查一次的輪詢，作業系統級的事件通知是真正的「即時」。當檔案被儲存的那一刻，系統就能立即感知到。

在專案中，`main.py` 負責初始化 `Observer` 物件，這是 `watchdog` 函式庫的核心。`Observer` 就像一個總指揮，它會為其排程一個我們自訂的事件處理器——`ExcelFileEventHandler`。`Observer` 會在一個獨立的背景執行緒中執行，靜默地監聽 `settings.WATCH_FOLDERS` 中指定的所有資料夾及其子資料夾中的所有檔案系統活動。一旦有相關事件發生，它就會將事件轉發給 `ExcelFileEventHandler` 進行處理。

### 3.2 `on_modified` 事件的挑戰：為何會出現「事件風暴」？

儘管 `watchdog` 提供了即時且高效的事件通知，但現實世界中的檔案操作遠比我們想像的要複雜。當使用者在 Excel 中按下 `Ctrl+S` 儲存一個檔案時，作業系統層面發生的事情遠比「一次修改」要複雜。Excel 為了確保檔案的安全性、完整性以及處理可能的回復點，通常會執行一系列複雜的、非原子性的操作。

例如，一個典型的 Excel 儲存過程可能包括：

1.  **建立一個臨時檔案**：Excel 會在原始檔案的同一個目錄下，創建一個以 `~$` 開頭的臨時檔案（例如 `~$MyReport.xlsx`）。
2.  **將變更寫入臨時檔案**：所有新的數據和變更都會被寫入這個臨時檔案。
3.  **刪除原始檔案**：一旦臨時檔案寫入完成，Excel 會刪除原始的 `MyReport.xlsx`。
4.  **重新命名臨時檔案**：最後，Excel 會將臨時檔案 `~$MyReport.xlsx` 重新命名為 `MyReport.xlsx`。

這一系列複雜的操作，可能會在極短的時間內觸發**多次** `on_modified` 甚至 `on_created` 和 `on_deleted` 事件。這就是所謂的「事件風暴」(Event Storm)。

如果我們對每一個 `on_modified` 事件都立即觸發一次完整的 Excel 讀取和比較分析，將會導致嚴重的問題：

*   **資源浪費**：對同一個檔案的單次儲存操作，系統卻進行了多次不必要的讀取和比較。這會消耗大量的 CPU 和磁碟 I/O 資源。
*   **邏輯混亂與數據不一致**：在 Excel 的原子性儲存操作完成之前，我們可能會讀到一個不完整、正在寫入中或已損壞的中間狀態檔案。例如，在臨時檔案還沒完全寫入，或者原始檔案還沒被刪除時就去讀取，這會導致比較結果不準確，甚至可能因為讀取到錯誤的數據而導致程式崩潰。
*   **競爭條件與檔案鎖定**：當系統正在處理前一個事件（例如，正在讀取檔案）時，後一個事件又觸發了同一個檔案的處理。這可能導致檔案被鎖定，使得系統無法讀取，或者引發其他難以預測的競爭條件問題。

為了解決這個核心挑戰，Excel Monitor 引入了兩道關鍵的防線，它們像兩道智慧的過濾器，確保只有真正穩定且有意義的變更信號才能進入核心處理流程：**防抖動**和**智慧輪詢**。

### 3.3 防抖動 (`DEBOUNCE_INTERVAL_SEC`)：過濾掉短時間內的重複事件

防抖動 (Debouncing) 是一個在事件處理中非常經典且實用的模式，其理念是：**在一個事件觸發後，等待一個短暫的「冷卻期」或「延遲週期」；如果在這個週期內又有相同的事件進來，則重置延遲週期。只有當延遲週期完整地結束而沒有新事件進來時，才真正執行處理函數。**

**類比**：想像一個老式的電梯按鈕，你按下它，但它會「彈跳」幾下，發出多個電信號。如果電梯系統對每個信號都響應，電梯門就會不斷開關。防抖動機制就像一個智能電路，它會等待按鈕完全穩定下來（彈跳結束）後，才發出一個單一的、有效的「開門」指令。

在 `ExcelFileEventHandler` 的 `on_modified` 方法中，這個機制的實現如下：

1.  **記錄時間戳**：系統使用一個字典 `self.last_event_times`。這個字典的鍵是 Excel 檔案的完整路徑 (`file_path`)，值是該檔案最後一次被 `on_modified` 事件處理的時間戳。
2.  **檢查冷卻期**：當一個新的 `on_modified` 事件進來時，系統會獲取當前時間 `current_time`。然後，它會計算 `current_time` 與該檔案上次被處理時間之間的差值。
3.  **過濾重複事件**：
    *   如果這個時間差**小於** `settings.DEBOUNCE_INTERVAL_SEC`（例如，預設是 2 秒），這意味著這是一個在防抖動週期內的重複事件（很可能是 Excel 儲存操作引起的「彈跳」）。此時，系統會直接 `return`，忽略這個事件，不進行任何處理。
    *   如果這個時間差**大於或等於** `settings.DEBOUNCE_INTERVAL_SEC`，這才被認為是一個「有效」的、獨立的變更事件。系統會更新 `self.last_event_times[file_path] = current_time`，並繼續執行後續的處理邏輯。

這道防線能夠有效地將來自單次儲存操作的「事件風暴」，過濾成**唯一一個**有效的觸發信號，極大地簡化了後續處理的複雜性，避免了對同一個檔案進行重複且無效的處理。

### 3.4 智慧輪詢 (`ActivePollingHandler`)：即時與穩定的終極平衡

即使通過了防抖動，我們仍然面臨一個問題：我們無法 100% 確定收到的那「唯一一個」`on_modified` 事件，就代表著檔案已經完全寫入磁碟並處於穩定狀態。特別是在處理大型檔案、位於網路磁碟 (Network Drive) 上的檔案，或者當使用者在短時間內連續儲存一個檔案時，寫入操作可能會持續數秒鐘。如果在寫入過程中就去讀取檔案，很可能會失敗或讀到不完整的資料。

為此，專案設計了 `ActivePollingHandler`，一個精巧的**自適應輪詢處理器**。它的核心職責是：**在收到一個有效的變更信號後，接管對該檔案的監控，並通過主動、重複地檢查，直到確認該檔案真正穩定下來為止。**

#### 3.4.1 為何需要輪詢？

*   **應對寫入延遲**：確保在檔案的 I/O 操作完全結束後，才進行比較。這就像你給一個大水桶裝水，你不會在水龍頭還開著的時候就去測量水桶裡的水量，你會等水龍頭關閉，水面完全平靜後再去測量。
*   **處理連續修改**：如果使用者在短時間內連續儲存一個檔案（例如，修改後儲存，然後又立即修改並再次儲存），輪詢可以將這些連續的變更合併處理，只在最後一次變更穩定後才更新基準線。這避免了為每一次微小變更都生成一個日誌條目，使得日誌更加簡潔和有意義。
*   **提升健壯性**：對於網路不穩定（可能導致檔案讀取失敗）或檔案暫時被其他應用程式鎖定（例如，Excel 仍然打開著檔案）的情況，輪詢的重試機制可以大大提高讀取成功的機率。它會不斷嘗試，直到成功讀取或達到某個超時限制。

#### 3.4.2 密集輪詢 vs. 稀疏輪詢：自適應的智慧

不同的檔案，其變更的風險和處理成本是不同的。一個 100KB 的小型設定檔，其寫入過程幾乎是瞬時的；而一個 100MB 的大型資料模型，其寫入過程可能需要好幾秒甚至更長。如果對所有檔案都使用相同的輪詢間隔，顯然是不夠智慧的。

`ActivePollingHandler` 的 `start_polling` 方法實現了自適應策略，它會根據檔案的大小來動態調整輪詢的頻率：

1.  **判斷檔案大小**：它首先會檢查檔案的大小 (`os.path.getsize`)。
2.  **閾值劃分**：系統會將檔案大小與 `settings.POLLING_SIZE_THRESHOLD_MB`（例如，預設是 10MB）進行比較。
3.  **選擇策略**：
    *   如果檔案大小**小於** `POLLING_SIZE_THRESHOLD_MB`，則將其歸類為**密集輪詢 (Dense Polling)**。這類檔案通常寫入速度快，因此使用一個較短的檢查間隔 `settings.DENSE_POLLING_INTERVAL_SEC`（例如，預設是 10 秒），以便更快地確認其穩定性。
    *   如果檔案大小**大於或等於** `POLLING_SIZE_THRESHOLD_MB`，則將其歸類為**稀疏輪詢 (Sparse Polling)**。這類檔案寫入時間可能較長，因此使用一個較長的檢查間隔 `settings.SPARSE_POLLING_INTERVAL_SEC`（例如，預設是 15 秒），以減少不必要的頻繁檢查，降低系統負載。

這種基於檔案大小的動態策略，使得系統可以將更多的監控資源投入到那些更可能出現寫入延遲的大型檔案上，同時又不會過度消耗資源在小型檔案上，實現了資源分配的優化。

#### 3.4.3 輪詢的穩定性：如何確認檔案已穩定？

輪詢的核心邏輯在 `_poll_for_stability` 方法中，它通過一個巧妙的遞迴計時器 (`threading.Timer`) 實現。這個計時器就像一個鬧鐘，每隔一段時間就會提醒系統去檢查檔案：

1.  **啟動**：當 `start_polling` 被呼叫時，它會設定一個 `threading.Timer`，在指定的 `interval`（例如 10 秒）後執行 `_poll_for_stability`。
2.  **檢查**：`_poll_for_stability` 執行時，它會呼叫 `compare_excel_changes` 來檢查檔案的當前狀態與基準線是否有差異。
3.  **決策**：
    *   **如果 `compare_excel_changes` 返回 `True` (表示 `has_changes`)**：這意味著在這次輪詢檢查時，檔案內容相比於上一次的基準線**又發生了變化**。這是一個強烈的信號，表明檔案仍在被積極修改（例如，使用者正在連續儲存）。此時，系統會**延長輪詢**，即建立一個**新的 `Timer`**，在下一個 `interval` 後再次執行 `_poll_for_stability`。這就像你發現水桶裡的水還在晃動，就知道水還沒完全裝滿，於是你繼續等待。
    *   **如果 `compare_excel_changes` 返回 `False` (表示 `no_changes`)**：這意味著在這次輪詢檢查時，檔案內容與基準線完全一致。這說明，從上一次變更被記錄並更新基準線之後，到現在為止，檔案沒有再發生任何新的變動。系統可以合理地認為，該檔案已經達到了**穩定狀態**。這就像水桶裡的水面已經完全平靜，你知道水已經裝滿了。
4.  **結束**：一旦確認檔案穩定，系統就會從 `self.polling_tasks` 字典中移除該檔案的任務，從而正式結束對該檔案的本輪輪詢監控。

### 3.5 即時比較與後續輪詢的協同工作

現在我們可以完整地梳理出 `on_modified` 的最終工作流程，這是一個即時響應和後續驗證的完美結合。它確保了系統既能快速響應，又能穩定可靠地處理複雜的檔案變更場景：

1.  **事件觸發**：使用者儲存 Excel 檔案，`watchdog` 偵測到 `on_modified` 事件並觸發 `ExcelFileEventHandler` 的 `on_modified` 方法。
2.  **防抖過濾**：`on_modified` 首先會執行防抖動檢查。如果這是短時間內的重複事件，它會被直接忽略，避免不必要的處理。
3.  **輪詢狀態檢查**：如果事件通過防抖動，系統會檢查該檔案是否**已經**處於輪詢狀態（即 `file_path` 是否存在於 `self.polling_handler.polling_tasks` 中）。
    *   **如果檔案正在輪詢中**：這意味著系統已經在積極地監控該檔案的穩定性。此時，`on_modified` 會直接忽略本次事件，因為輪詢器會負責在適當的時機進行比較和日誌記錄。這避免了重複觸發。
    *   **如果檔案不在輪詢中**：這是一個新的、獨立的變更事件，需要立即處理。
4.  **即時比較 (The First Check)**：對於不在輪詢中的檔案，系統會**立即**呼叫 `compare_excel_changes(file_path, silent=False, event_number=self.event_counter, is_polling=False)` 進行一次比較。
    *   **目的**：這是為了提供最快的即時反饋。它會顯示詳細的差異表格到控制台，並記錄**第一次**的變更日誌到 CSV 檔案。`is_polling=False` 參數在這裡非常重要，它告訴 `compare_excel_changes` 這是第一次即時檢查，應該記錄日誌。
    *   **結果**：如果 `compare_excel_changes` 返回 `True`，表示發現了變更；如果返回 `False`，表示沒有即時變更（例如，只是檔案的元數據變了，內容沒變）。
5.  **基準線更新**：在即時比較後，如果發現了變更，基準線會被**立即更新**。這是後續輪詢能夠判斷穩定性的關鍵。
6.  **啟動輪詢**：無論即時比較是否發現變更，系統都會呼叫 `self.polling_handler.start_polling(file_path, self.event_counter)`，啟動對該檔案的後續輪詢監控。這確保了即使檔案在即時檢查後又被連續修改，系統也能捕捉到這些變更。
7.  **輪詢驗證**：輪詢器會在指定間隔後開始工作。它後續的每一次 `compare_excel_changes` 呼叫，都是將檔案的「現在」與**剛剛在第5步更新的基準線**進行比對。
    *   **`is_polling=True`**：在輪詢階段，`compare_excel_changes` 會帶上 `is_polling=True` 參數。這告訴函數，它是在輪詢模式下被呼叫的，此時**不應該重複記錄日誌**，因為第一次的日誌已經記錄了。它只負責判斷檔案是否穩定。
    *   **穩定性判斷**：如果沒有任何新的變更，輪詢就會很快結束。如果使用者在輪詢期間又儲存了檔案，輪詢器會捕捉到新的變更，再次更新基準線，並延長輪詢週期。

這個設計確保了系統既能像哨兵一樣對第一次變更做出即時反應（顯示表格、記錄日誌），又能像一個耐心的偵探一樣，通過後續的輪詢來確認現場（檔案）是否已完全平靜，從而保證了資料的最終一致性和系統的健壯性。